https://blog.csdn.net/zdplife/article/details/90106518

表空间
InnoDB 所有数据都存放在一个空间中，称之为表空间，表空间由段，区，页组成。
innodb_file_per_table 参数：
InnoDB 默认情况下所有表的数据都存放在共享表空间 ibdata1 中，该参数决定了是否每为张表内的数据单独设置一个表空间。
如果开启该功能，单独表空间中只存放数据、索引、插入缓存 Bitmap 页，其它数据包括回滚信息，插入缓存索引页，系统事务信息等还是存放在原来的共享表空间中。

段 区 页 行

段
表空间由各个段组成，主要分为索引段，数据段以及回滚段。其中数据段存放在 B+ 树的叶子节点，索引段存放在 B+ 树的非叶子节点。

区

区由连续的页组成：
每个区的大小是固定的：1MB
默认页的大小是 16KB，所以一个区中有 64 个连续页。
innodb_page_size 参数，在 1.2.x 版本以后可以设置对页的大小进行设置。
当创建一个表时，并不是直接使用连续的 64 个页存放数据，而是先用每个段开始时的 32 个碎片页来存放数据，等使用完这些碎片页才开始申请 64 个连续页，这样做的主要目的对于一些小表，刚开始可以申请较少的空间，节省磁盘容量的开销。

页

InnoDB 存储引擎中，常见的页的类型有：

数据和索引页
undo 页
系统页
事务数据页
插入缓存 Bitmap 页
插入缓存空闲列表页
未压缩的二进制大对象页
压缩的二进制大对象页

行

InnoDB 存储引擎中，数据是按照行进行存放的，最多可以存放 7992 条行记录

sql 查询按照自定义顺序进行排序,如果不在记录中则排序在最前面
select * from tab_name order by field(field_name, str1, str2, str3)

执行计划 extra 
Using where; Using temporary; Using filesort

mysql 基本架构图
缓存 缓存查询结果
sql 语句和结果以键值对方式存储，缓存频繁失效标更新会导致缓存失效 命中率比较低

连接器 管理连接验证权限
show processlist 查看现在的链接，wait_timeout 默认8个小时
show variables like 'wait_timeout'; 查询链接等待时间

分析器 词法分析、语法分析


优化器 执行计划索引选择
选择索引 多变关联决定关联顺序
rbo 基于规则优化 cbo 基于成本优化

执行器 操作引擎返回结果

存储引擎 存储数据，提供读写接口 

redo log 数据修改先更新redo log 并更新内存， innodb 引擎会在适合时机记录到磁盘
redo log 有固定大小，循环写数据 

undo log 是为了实现事务的原子性， undo log 实现 mvcc undo log 也是逻辑日志
在执行任何数据之前，先需要进行数据备份，然后进行修改，如果执行错误需要 rollback 

bin log 是 server 层日志
1 redo log 是innodb 特有的，bin log 是所有引擎都可以用的
2 redo log 是物理日志，记录了数据页的修改 而bin log 是逻辑日志，记录语句的原始逻辑
3 redo log 是循环写的，空间会用完 而 bin log 是可以追加的，不会产生覆盖

bin log 会记录所有的逻辑操作，追加的方式写入，一般用于全量备份

create/alter table 以及 insert/update/delete 的二进制日志，主从数据库同步用到的都是binlog

statement 模式

只记录引起数据库变更的sql 语句，该模式性能最优，没有记录实际的数据，所以日志量日志量和 IO 都消耗很低，性能是最优的。但是如果使用 
uuid 和 now 等函数，结果不确定。

row 模式

会记录每一行的操作记录，可以绝对精准的还原，从而保证了数据的安全与可靠，并且复制和数据恢复过程可以是并发进行的，缺点是binlog 日志体积大。性能消耗较多。

mixed 模式

前两中的混合模式，大多数情况下使用statement,不确定结果的时候使用row 模式。

relay log   sql thread 





redo log 两阶段提交
先写 redo log 再写 bin log 
先写 bin log 再写 redo log 


repeat('b',1024*1024*5) 重复函数 
select @@max_allowed_packet;

max_allowed_packet控制communication buffer最大尺寸，当发送的数据包大小超过该值就会报错，我们都知道，MySQL包括Server层和存储引擎，
它们之间遵循2PC协议，Server层主要处理用户的请求：连接请求—>SQL语法分析—>语义检查—>生成执行计划—>执行计划—>fetch data；
存储引擎层主要存储数据，提供数据读写接口。

show profiles;
show profile cpu,block io for query 1;  
mysql.slow_log记录的是执行超过long_query_time的所有SQL，如果遵循MySQL开发规范，slow query不会太多，
但是开启了log_queries_not_using_indexes=ON就会有好多full table scan的SQL被记录，这时slow_log表会很大，对于RDS来说，一般只保留一天的数据，
在频繁insert into slow_log的时候，做truncate table slow_log去清理slow_log会导致MDL，影响MySQL稳定性。
建议将log_output=FILE，开启slow_log， audit_log，这样就会将slow_log，audit_log写入文件，
通过Go API处理这些文件将数据写入分布式列式数据库clickhouse中做统计分析。

由于MySQL是单进程多线程模型，一个SQL语句无法利用多个cpu core去执行，这也就决定了MySQL比较适合OLTP（特点：大量用户访问、逻辑读，索引扫描，
返回少量数据，SQL简单）业务系统，同时要针对MySQL去制定一些建模规范和开发规范，尽量避免使用Text类型，它不但消耗大量的网络和IO带宽，
同时在该表上的DML操作都会变得很慢。另外建议将复杂的统计分析类的SQL，建议迁移到实时数仓OLAP中，例如目前使用比较多的clickhouse，
里云的ADB，AWS的Redshift都可以，
做到OLTP和OLAP类业务SQL分离，保证业务系统的稳定性。

id_log_file_0 
write pos 是当前记录的位置，一边写一遍后移，是一个循环的写入的过程
checkpoint 是当前要擦除的位置，也是不断往后推移并且循环的，擦除记录前需要将记录更新到数据文件中
write pos 和 checkpoint 之前是可以写的部分，保存新的记录操作，如果 write pos 追上了 checkpoint 那么表示空间满了，
不能继续执行更新操作 需要等待checkpoint 擦除一些记录然后才能写入

数据库发生一次，之前提交的记录不会丢失，这个能力称之为 crash-safe 

![](./../images/20201215101855.png)

mysql sql 执行顺序

![](./../images/20201216123638.png)

```
查看 binlog 的日志模式 
show global variables like "%binlog_format%"; 
log-bin = /data/3306/mysql-bin  
binlog_format="STATEMENT"  
#binlog_format="ROW"  
#binlog_format="MIXED" 

```

1 数据库开启主从同步流程时，主节点需要开启二进制日志，记录任何修改了数据库的事件
2 从节点开始一个线程(I/O thread ) 使用mysql 协议请求二进制日志文件的事件
3 主节点启动一个线程(dump thread),检查自己二进制日志时间，跟对方请求的位置对比，增量发送，如果没有位置参数，则发送所有时间给从节点
4 从节点接收到主节点的数据后放置到中继日志里(relay log)中，并记录该次主节点的二进制日志文件文职
5 从节点启动一个(sql thread),把relay log 的时间读取出来,在本地执行一次。

mysql 的复制方式是异步的，并且具有并行复制能力，
全量同步复制和半同步复制
全量同步 所有的日志全部同步至从库才算成功
半同步   从库写入日志成功后返回ack给主库，主库至少收到一个才算成功
主备切换 可靠性优先还是可用性优先

mysql 中的索引常见模型为 哈希表、有序数组、搜索树
哈希表：一种以KV存储数据的结构，只适合等值查询，不适合范围查询。
有序数组：只适用于静态存储引擎，涉及到插入的时候比较麻烦。可以参考Java中的ArrayList。
搜索树：按照数据结构中的二叉树来存储数据，不过此时是N叉树(B+树)。广泛应用在存储引擎层中。

搜索树的结构
![](./../images/20201216152403.png)

1 B+ 树非叶子节点存储的只是索引，可以存储的更多。B+树比B树更加矮胖，IO次数更少。
2 B+ 树叶子节点前后管理，更加方便范围查询。同时结果都在叶子节点，查询效率稳定。
3 B+ 树中更有利于对数据扫描，可以避免B树的回溯扫描。
回表的概念

索引的优点：
1、唯一索引可以保证每一行数据的唯一性 
2、提高查询速度 
3、加速表与表的连接 
4、显著的减少查询中分组和排序的时间
5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
索引的缺点：
1、创建跟维护都需要耗时 
2、创建索引时，需要对表加锁，在锁表的同时，可能会影响到其他的数据操作 
3、 索引需要磁盘的空间进行存储，磁盘占用也很快。
4、当对表中的数据进行CRUD的时，也会触发索引的维护，而维护索引需要时间，可能会降低数据操作性能
索引设计的原则不应该：
1、索引不是越多越好。索引太多，维护索引需要时间跟空间。
2、频繁更新的数据，不宜建索引。
3、数据量小的表没必要建立索引。
应该：
1、重复率小的列建议生成索引。因为重复数据少，索引树查询更有效率，等价基数越大越好。
2、数据具有唯一性，建议生成唯一性索引。在数据库的层面，保证数据正确性 
3、频繁group by、order by的列建议生成索引。可以大幅提高分组和排序效率 
4、经常用于查询条件的字段建议生成索引。通过索引查询，速度更快

时间 空间 成本

索引失效的场景
1、模糊搜索：左模糊或全模糊都会导致索引失效，比如'%a'和'%a%'。但是右模糊是可以利用索引的，比如'a%' 。
2、隐式类型转换：比如select * from t where name = xxx , name是字符串类型，但是没有加引号，所以是由MySQL隐式转换的，所以会让索引失效 
3、当语句中带有or的时候：比如select * from t where name=‘sw’ or age=14
4、不符合联合索引的最左前缀匹配：(A,B,C)的联合索引，你只where了C或B或只有B,C

关于索引的知识点：
1 主键索引：主键索引的叶子节点存的是整行数据信息。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。主键自增是无法保证完全
自增的哦，遇到唯一键冲突、事务回滚等都可能导致不连续。
2 唯一索引：以唯一列生成的索引，该列不允许有重复值，但允许有空值(NULL)
3 普通索引跟唯一索引查询性能：InnoDB 的数据是按数据页为单位来读写的，默认每页16KB，因此这两种索引查询数据性能差别微乎其微。
4 change buffer：普通索引用在更新过程的加速，更新的字段如果在缓存中，如果是普通索引则直接更新即可。如果是唯一索引需要将所有数据读入内
存来确保不违背唯一性，所以尽量用普通索引。
5 非主键索引：非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）
6 回表：先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。
7 覆盖索引：如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。
8 联合索引：相对单列索引，组合索引是用多个列组合构建的索引，一次性最多联合16个。
9 最左前缀原则：对多个字段同时建立的组合索引(有顺序，ABC，ACB是完全不同的两种联合索引) 以联合索引(a,b,c)为例，建立这样的索引相当于建
立了索引a、ab、abc三个索引。另外组合索引实际还是一个索引，并非真的创建了多个索引，只是产生的效果等价于产生多个索引。
10 索引下推：MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。
11 索引维护：B+树为了维护索引有序性涉及到页分裂跟页合并。增删数据时需考虑页空间利用率。
12 自增主键：一般会建立与业务无关的自增主键，不会触发叶子节点分裂。
13 延迟关联：通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。
14 InnoDB存储: * .frm文件是一份定义文件，也就是定义数据库表是一张怎么样的表。*.ibd文件则是该表的索引，数据存储文件，既该表的所有索引树
，所有行记录数据都存储在该文件中。
15 MyISAM存储：* .frm文件是一份定义文件，也就是定义数据库表是一张怎么样的表。* .MYD文件是MyISAM存储引擎表的所有行数据的文件。* .MYI
文件存放的是MyISAM存储引擎表的索引相关数据的文件。MyISAM引擎下，表数据和表索引数据是分开存储的。
16 MyISAM查询：在MyISAM下，主键索引和辅助键索引都属于非聚簇索引。查询不管是走主键索引，还是非主键索引，在叶子结点得到的都是目的数据的
地址，还需要通过该地址，才能在数据文件中找到目的数据。
PS：InnoDB支持聚簇索引，MyISAM不支持聚簇索引

ACID的四个特性
1 原子性（Atomicity）：把多个操作放到一个事务中，保证这些操作要么都成功，要么都不成功
2 一致性（Consistency）：理解成一串对数据进行操作的程序执行下来，不会对数据产生不好的影响，比如凭空产生，或消失
3 隔离性（Isolation，又称独立性）：隔离性的意思就是多个事务之间互相不干扰，即使是并发事务的情况下，他们只是两个并发执行没有交集，互不影响的东西；当然实现中，也不一定需要这么完整隔离性，即不一定需要这么的互不干扰，有时候还是允许有部分干扰的。所以MySQL可以支持4种事务隔离性
4 持久性（Durability）：当某个操作操作完毕了，那么结果就是这样了，并且这个操作会持久化到日志记录中

事务操作可能会出现的数据问题
1、脏读(dirty read)：B事务更改数据还未提交，A事务已经看到并且用了。B事务如果回滚，则A事务做错了 
2、 不可重复读(non-repeatable read)：不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了，只需要锁住满足条件的记录 
3、 幻读(phantom read)：事务A先修改了某个表的所有纪录的状态字段为已处理，未提交；事务B也在此时新增了一条未处理的记录，并提交了；事务A随后查询记录，却发现有一条记录是未处理的造成幻读现象，幻读仅专指新插入的行。幻读会造成语义上的问题跟数据一致性问题。
4、 在可重复读RR隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在当前读下才会出现。要用间隙锁解决此问题。
