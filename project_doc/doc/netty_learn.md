1、NIO存在的问题：

NIO的API比较复杂，需要熟练掌握3个核心组件，channel、buffer和selector；
需要熟悉多线程、网络编程等技术；
开发工作量大，难度也比较大，需要解决断连、重连、网络闪断、半包读写、失败缓存、网络拥堵等各种情况；
NIO存在bug，一个叫Epoll的bug，会导致选择器空轮询，形成死循环，最后CPU飙到100%
正是因为NIO存在这些问题，netty就应运而生了。


netty是一个异步的，基于事件驱动的网络应用框架。可以快速地开发高性能的服务器端和客户端，像dubbo和elasticsearch底层都用了netty。
它具有以下优点：

    设计优雅，灵活可扩展；
    使用方便，用户指南清晰明确；
    安全，完整的SSL/TLS和StartTLS支持；
    社区活跃，不断地更新完善
1、线程模型：
目前存在的线程模式：传统阻塞IO的服务模型和Reactor模式

根据Reactor的数量和处理资源的线程数不同，又分3种：
1 单Reactor单线程；
2 单Reactor多线程；
3 主从Reactor多线程

Netty的线程模型是基于主从Reactor多线程做了改进。

2、传统阻塞IO的线程模型：
采用阻塞IO获取输入的数据，每个连接都需要独立的线程来处理逻辑。存在的问题就是，当并发数很大时，就需要创建很多的线程，占用大量的资源。连接创建后，如果当前线程没有数据可读，该线程将会阻塞在读数据的方法上，造成线程资源浪费。

3、Reactor模式(分发者模式/反应器模式/通知者模式)：
针对传统阻塞IO的模型，做了以下两点改进：

    基于IO复用模型：多个客户端共用一个阻塞对象，而不是每个客户端都对应一个阻塞对象
    基于线程池复用线程资源：使用了线程池，而不是每来一个客户端就创建一个线程

Reactor模式的核心组成：

    Reactor：Reactor就是多个客户端共用的那一个阻塞对象，它单独起一个线程运行，负责监听和分发事件，将请求分发给适当的处理程序来进行处理
    Handler：处理程序要完成的实际事件，也就是真正执行业务逻辑的程序，它是非阻塞的

