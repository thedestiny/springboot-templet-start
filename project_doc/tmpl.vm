## Quick Settings - configure common code-style and other settings here. -----------------------------------------------
## Set these to use special prefixes for test-class members containing dependencies of certain types.
## Note that the template code below will ignore any prefix set to "" and use your IDE code style settings instead.
#set($dependencyMemberNamePrefix = "")
#set($mockDependencyMemberNamePrefix = "mock")
## Set this to use a special prefix for local fields containing arguments for test methods.
#set($parameterLocalFieldNamePrefix = "")
#set($mockParameterLocalFieldNamePrefix = "mock")
## Customize the name of the member and local field (if needed) used to store the instance of the source class.
#set($sourceClass.testClassMemberName = "${sourceClass.testClassMemberName}UnderTest")
#set($sourceClass.testClassLocalFieldName = "${sourceClass.testClassLocalFieldName}UnderTest")
## Configure how Bean DTOs are initialized.
#set($maxRecursiveBeanInitDepth = 10)
#set($maxNumberOfSettersToCallPerClass = 10)
#set($maxNumberOfSettersToCall = 70)
#set($useStaticImportForInitMocks = true)
## Set this to use mocks for mockable method parameters that end in "listener" or "callback" ignoring case.
#set($useMocksForListenerAndCallbackParameters = true)
#set($generateStubsAndVerifyStatements = true)
## Use this to specify custom initialization values for dependencies and method parameters of certain types;
## See https://squaretest.com#template_api_quick_settings for details.
#set($initExpressionOverrides = {} )
##----------------------------------------------------------------------------------------------------------------------

## Initialize the data model. This sets global variables based on the architype of the source class and Quick Settings.
## See the comments above the macro or https://squaretest.com#template_api_initializeTemplateDataModel for details.
#initializeTemplateDataModel()

## Package declaration
#if($StringUtils.isNotEmpty($sourceClass.packageName))
package $sourceClass.packageName;
#end

## Imports; Note that Squaretest invokes IntelliJ's import organize and code reformatter after creating the test class.
#foreach($importLine in $importLinesRequired)
    $importLine
#end
#if($useStaticImportForInitMocks)
import static org.mockito.MockitoAnnotations.initMocks;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
#end
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.within;
#renderImportsForMatchers()
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.InjectMocks;
import org.mockito.stubbing.Answer;

## Test class
public class ${sourceClass.name}Test {

## Declare member fields for the dependencies.
#renderMemberDeclarations($mockMemberFields)
#renderMemberDeclarations($nonMockMemberFields)

## Declare a member field for the instance of the source class.
#if($sourceClassMemberNeeded)
    #if($shouldUseInjectMocks) @InjectMocks #end
    private ${sourceClass.type.canonicalText} ${sourceClass.testClassMemberName};
#end

## Render setUp() only if we need to instantiate source class.
#if($sourceClassMemberNeeded)
@Before
public void setUp() {
    #if($mocksNeeded)
        #if(!$useStaticImportForInitMocks)MockitoAnnotations.#end initMocks(this);
    #end
    ## Initialize the non-mock member fields.
    #foreach($field in $nonMockMemberFields)
        $field.testClassMemberName = $field.initExpression;
    #end
    ## Initialize the member containing the source class.
    #if($sourceClass.singleton)
${sourceClass.testClassMemberName} = $sourceClass.singletonAccessExpression;
    #elseif($shouldUseInjectMocks) ## Do nothing.
    #elseif($sourceClass.preferredConstructor)
        ## Invoke the constructor.
${sourceClass.testClassMemberName} = new #methodCall($sourceClass.preferredConstructor, true) #if($sourceClass.abstract)$sourceClass.abstractClassBody#end;
        #if($shouldSetPackageLocalFields)
            #foreach($field in $dependencies)
${sourceClass.testClassMemberName}.${field.declaredName} = #if($field.shouldStoreInReference) $field.testClassMemberName #else $field.initExpression #end;
            #end
        #end
    #else
        ## As a fallback, set the member to null and leave a comment.
${sourceClass.testClassMemberName} = null /* TODO: construct the instance */;
    #end
}
#end
## Render the test methods.
#if($shouldCreateTestsForInstanceMethods)
    #renderTestMethods($sourceClass.publicInstanceMethods)
    #renderTestMethods($sourceClass.packageLocalInstanceMethods)
    #renderTestsForProtectedMethodsIfNeeded()
#end
#renderTestMethods($sourceClass.publicStaticMethods)
#renderTestMethods($sourceClass.packageLocalStaticMethods)
}

## Macros
## Add your own macros here. Newlines between macros will not appear in the generated test class;
## Squaretest automatically removes all but 1 newline at the end of the generated test class.

##----------------------------------------------------------------------------------------------------------------------
## renderMemberDeclarations($fields)
## Renders test-class member declarations for the given List<Variable>.
    ## Param: $fields - the list of variables for which to render declarations.
    ##----------------------------------------------------------------------------------------------------------------------
    #macro(renderMemberDeclarations $fields)
    #foreach($field in $fields)
    #if($field.shouldBeMocked) @Mock #end
    private $field.type.canonicalText $field.testClassMemberName;
    #end
    #end

    ##----------------------------------------------------------------------------------------------------------------------
    ## renderTestsForProtectedMethodsIfNeeded()
    ## Renders tests for protected methods if the class meets certain criteria.
    ##----------------------------------------------------------------------------------------------------------------------
    #macro(renderTestsForProtectedMethodsIfNeeded)
    #if($sourceClass.allSuperTypes.contains('javax.servlet.http.HttpServlet'))
    #renderTestMethods($sourceClass.protectedInstanceMethods)
    #end
    #end

    ##----------------------------------------------------------------------------------------------------------------------
    ## renderTestMethods($methods)
    ## Renders tests for the given List<Method>. This filters out getters/setters and other methods for which tests should
        ## not be rendered.
        ## Param: $methods - the list of methods for which to render tests.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderTestMethods $methods)
        #foreach($method in $methods.filterOut('simpleGetterOrSetter').filterOut('abstract'))
        #if($method.shouldUseSimpleTest)
        #renderSimpleTestMethod($method)
        #else
        #renderTestMethod($method, false, false, false)
        #renderTestMethodsForAltFlows($method)
        #end
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderTestMethodsForAltFlows($method)
        ## Renders test for alternate flows for the given method.
        ## Param: $method - the method for which to render alt-flow tests.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderTestMethodsForAltFlows $method)
        ## Render tests for exceptions declared by the source method.
        ## Determine if at at least one dependency interaction that we've mocked throws an exception.
        #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
        #set($macro.atLeastOneMockedDiThrows = $macro.mockedDIs.containsAnyWith('method.throwsException', true))
        #if((!$macro.atLeastOneMockedDiThrows) || (!$generateStubsAndVerifyStatements))
        ## Only render tests for the source method's declared exceptions if none of the source method's mocked DIs throw.
        ## If one of the mocked DIs throw, that test case will likely be the case where the source class throws the
        ## declared exception(s).
        #foreach($declaredException in $method.declaredExceptions)
        #renderTestMethod($method, $declaredException, false, false)
        #end
        #end
        #if(!$generateStubsAndVerifyStatements)#break #end
        ## Render tests for exceptions thrown by dependencies the source method interacts with.
        ## Create a test for each exception thrown by each dependency interaction that:
        ## 1. throws a checked exception and
        ## 2. has a dependency for which we've provided a mock.
        #foreach($di in $macro.mockedDIs)
        #foreach($exception in $di.method.declaredExceptions)
        #if($method.declaredExceptions.containsAnyWith('type.canonicalName', $exception.type.canonicalName))
        ## If the source method throws a checked exception of the same type as the exception thrown by this
        ## dependency interaction, assume it simply lets the exception bubble up; in this case, the test-case
        ## should expect the source-method to throw the $exception.
        #set($macro.expectedException = $exception)
        #else
        #set($macro.expectedException = false)
        #end
        #renderTestMethod($method, $macro.expectedException, $di, $exception)
        #end
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderTestMethod($method, $expectedException, $diThatThrows, $exceptionToThrow)
        ## Renders the test for the given Method.
        ## Param: $method - the method for which to render the test.
        ## Param: $expectedException  (optional) - the exception this test case is expected to throw (or false)
        ## Param: $diThatThrows       (optional) - the dependency interaction to stub to throw an exception (or false)
        ## Param: $diExceptionToThrow (optional) - the exception to stub $diThatThrows to throw (or false).
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderTestMethod $method, $expectedException, $diThatThrows, $diExceptionToThrow)
        #set($_ = $CodeStyleUtils.beginMethodScope())
        #if($sourceClass.enum)
        #renderTestMethodForEnum($method, $expectedException)
        #else
        ## Determine if we should create an assertEquals(...) call.
        #set($macro.returnTypeIsArrayWithComparableType = $method.returnType.array && ($method.returnType.deepArrayComponentType.primitive || $method.returnType.deepArrayComponentType.overridesEquals))
        #set($macro.shouldCreateAssertEqualsCall =
        $method.returnType && ($method.returnType.primitive || $method.returnType.overridesEquals || $method.returnType.array)
        && ($method.returnType.classT || $method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
        && !$expectedException)
        #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$method.returnType.simple)
        ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
        #determineTestCaseSuffix($method, $expectedException, $diThatThrows, $diExceptionToThrow)

        @Test
        public void test${StringUtils.capitalize(${method.name})}${testCaseSuffix}${method.overloadSuffix}() throws Exception {
        // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $method.parameters.filter('shouldStoreInReference', true))
        #declareAndInitLocalVar($param, true)
        #end
        #if($macro.shouldStoreExpectedValue)
        #declareAndInitLocalVar($method.returnType, true)
        #end
        #renderStubs($method, $diThatThrows, $diExceptionToThrow)

        // Run the test
        #set($macro.qualifier = "#if($method.static)${sourceClass.name}#else${sourceClass.testClassMemberName}#end")
        #if($expectedException)
        assertThatThrownBy(() -> {
    ${macro.qualifier}.#methodCall($method, false);
        }).isInstanceOf(${expectedException.type.canonicalName}.class).hasMessageContaining("message");
        #else
        #if($method.returnType) final $method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($method, false);

        // Verify the results
        #if($macro.shouldCreateAssertEqualsCall)
        #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$method.returnType.testClassLocalFieldName #else $method.returnType.initExpression #end")
        #assertEqualsCall($macro.expectedValueExpression, 'result', $method.returnType);
        #end
        #end
        #renderVerifyStatements($method, $diThatThrows, $diExceptionToThrow)
        }
        #end
        #set($_ = $CodeStyleUtils.endMethodScope())
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## assertEqualsCall($expected, $actual, $type)
        ## Renders the assertEquals method call appropriate for the given parameters.
        ## Param: $expected - the value to use for the expected argument of the assertEquals method call.
        ## Param: $actual - the value to use for the actual argument of the assertEquals method call.
        ## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(assertEqualsCall $expected, $actual, $type)
        #if($StringUtils.equalsAny($type.canonicalName, 'double', 'java.lang.Double')) assertThat($actual).isEqualTo($expected, within(0.0001)) #break
        #elseif($StringUtils.equalsAny($type.canonicalName, 'float', 'java.lang.Float')) assertThat($actual).isEqualTo($expected, within(0.0001f)) #break
        #elseif($StringUtils.equalsAny($type.canonicalName, 'boolean', 'java.lang.Boolean')) assertThat($actual).isTrue() #break
        #else assertThat($actual).isEqualTo($expected) #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderStubs($method, $diThatThrows, $exceptionToThrow)
        ## Renders the stubs (when, doAnswer, doThrow, etc) for the given test case.
        ## Param: $method - the method for which the test is being rendered.
        ## Param: $diThatThrows       (optional) - the dependency interaction to stub to throw an exception (or false)
        ## Param: $diExceptionToThrow (optional) - the exception to stub $diThatThrows to throw (or false).
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderStubs $method, $diThatThrows, $exceptionToThrow)
        #if(!$generateStubsAndVerifyStatements)#break #end
        #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
        #if($diThatThrows)
        #renderPrimaryFlowStubs($macro.mockedDIs.itemsBefore($diThatThrows))
        #renderAltFlowStub($diThatThrows, $exceptionToThrow)
        #renderPrimaryFlowStubs($macro.mockedDIs.itemsAfter($diThatThrows).filterOut('field.declaredName', $diThatThrows.field.declaredName))
        #else
        #renderPrimaryFlowStubs($macro.mockedDIs)
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderPrimaryFlowStubs($dis)
        ## Renders the primary flow stubs (when, doAnswer, etc) for the given dependency interactions.
        ## Param: $dis - the dependency interactions to render stubs for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderPrimaryFlowStubs $dis)
        #foreach($di in $dis)
        #renderPrimaryFlowStub($di)
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderPrimaryFlowStubs($di)
        ## Renders the primary flow stub (when, doAnswer, etc) for the given dependency interaction.
        ## Param: $di - the dependency interaction to render stubs for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderPrimaryFlowStub $di)
        #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
        #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
        #if($di.method.parameters.containsAnyWith('type.canonicalName', 'java.lang.Runnable'))
        #renderAnswerForRunnable($di)
        #elseif($di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable'))
        #renderAnswerForCallable($di)
        #elseif($di.method.returnType)
        #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
        ## Declare a local variable for the return type if needed.
        #if($di.method.returnType.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #declareAndInitLocalVar($di.method.returnType, false)
        #end
        #set($macro.returnTypeExpression = "#if($di.method.returnType.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.initExpression #end")
        #if($macro.hasInnerWildcardType)
        doReturn($macro.returnTypeExpression).when($macro.qualifier).#methodCall($di.method, false);
        #else
        when($macro.qualifier.#methodCall($di.method, false)).thenReturn($macro.returnTypeExpression);
        #end
        #if($di.method.returnType.shouldStoreInReference) $Newline #end
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderAnswerForRunnable($di)
        ## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Runnable.
        ## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderAnswerForRunnable $di)
        #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
        #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
        #set($macro.indexOfRunnable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.lang.Runnable'))
        doAnswer(invocation -> {
        ((Runnable) invocation.getArguments()[$macro.indexOfRunnable]).run();
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
        return CompletableFuture.completedFuture(null);
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
        final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
        settableFuture.set(null);
        return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
        final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
        doReturn(null).when(mockFuture).get();
        doReturn(true).when(mockFuture).isDone();
        return mockFuture;
        #elseif($di.method.returnType)
        return $di.method.returnType.initExpression;
        #else
        return null;
        #end
        }).when($macro.qualifier).#methodCall($di.method, false);
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderAnswerForCallable($di)
        ## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Callable.
        ## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderAnswerForCallable $di)
        #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
        #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
        #set($macro.indexOfCallable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.util.concurrent.Callable'))
        doAnswer(invocation -> {
        final Callable<?> callable = (Callable<?>) invocation.getArguments()[$macro.indexOfCallable];
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
        return CompletableFuture.completedFuture(callable.call());
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
        final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
        settableFuture.set(callable.call());
        return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
        final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
        doReturn(callable.call()).when(mockFuture).get();
        doReturn(true).when(mockFuture).isDone();
        return mockFuture;
        #elseif($di.method.returnType)
        return $di.method.returnType.initExpression;
        #else
        return null;
        #end
        }).when($macro.qualifier).#methodCall($di.method, false);
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderAltFlowStub($di, $exceptionToThrow)
        ## Configures the provided dependency interaction ($di) to throw the provided $exceptionToThrow.
        ## Param: $di - the dependency interaction to be configured to throw.
        ## Param: $exceptionToThrow - the exception the $di should throw.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderAltFlowStub $di, $exceptionToThrow)
        #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
        #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
        #if($di.method.returnType)
        when($macro.qualifier.#methodCall($di.method, false)).thenThrow(${exceptionToThrow.type.canonicalName}.class);
        #else
        doThrow(${exceptionToThrow.type.canonicalName}.class).when($macro.qualifier).#methodCall($di.method, false);
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## declareAndInitLocalVar($param, $addNewlineAfterBean)
        ## Declares and initializes a local variable for $param. If $param is a DTOBean, Squaretest will initialize its
        ## properties. Squaretest also initializes any DTOBeans required for the $param's initialization expression.
        ## Param: $param               - the Type or Variable to declare and initialize.
        ## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(declareAndInitLocalVar $param, $addNewlineAfterBean)
        #set($macro.isOrHasBean = $param.type.dtoBean || !$param.type.initExpressionBeans.empty)
        #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
        #if($StringUtils.equalsAny($param.type.canonicalName,
        'com.google.common.util.concurrent.ListenableFuture', 'com.google.common.util.concurrent.SettableFuture'))
        #declareAndInitListenableFuture($param)
        #elseif($param.type.dtoBean)
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #renderBeanSetupCodeForVar($param)
        #if($addNewlineAfterBean) $Newline #end
        #elseif(!$param.type.initExpressionBeans.empty)
        ## The parameter's initExpression has one or more beans; e.g. the bean in Optional.of(bean).
        ## Declare and init the beans first.
        #foreach($beanType in $param.type.initExpressionBeans)
        ## Declare the local field for the bean and initialize it.
        #declareAndInitLocalVar($beanType, false)
        #end
        #set($param.type.initExpression = $param.type.createInitExpressionWithLocalFieldBeans($param.type.initExpressionBeans))
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #else
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## declareAndInitListenableFuture($param)
        ## Helper macro to declare and initialize a ListenableFuture or SettableFuture.
        ## This method should only be called from #declareAndInitLocalVar(...), as it assumes the $param.testClassLocalFieldName
        ## has already been updated for the test method scope.
        ## Param: $param  - the Type or Variable to declare and initialize.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(declareAndInitListenableFuture $param)
        #set($macro.shouldSetInnerType = !$param.type.parameters.first.canonicalText.equals('?'))
        #set($macro.shouldStoreInnerTypeInVar = $macro.shouldSetInnerType && !$param.type.parameters.first.simple)
        #if($macro.shouldStoreInnerTypeInVar)
        #declareAndInitLocalVar($param.type.parameters.first, false)
        #end
        final com.google.common.util.concurrent.SettableFuture<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $param.type.initExpression;
        #if($macro.shouldSetInnerType)
        #if($macro.shouldStoreInnerTypeInVar)
    ${param.testClassLocalFieldName}.set($param.type.parameters.first.testClassLocalFieldName);
        #else
    ${param.testClassLocalFieldName}.set($param.type.parameters.first.initExpression);
        #end
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderBeanSetupCodeForVar($param)
        ## Renders the code necessary to configure the provided bean.
        ## Param: $param - the Type or Variable for which to render the bean setup code.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderBeanSetupCodeForVar $param)
        #set($macro.canonicalNamesInCallStack = {})
        #set($macro.canonicalNamesInCallStack[$param.type.canonicalName] = true)
        #set($macro.numberOfSettersCalled = $MutableInt.create(0))
        #renderBeanSetupCodeRecursively($param, $maxRecursiveBeanInitDepth, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled)
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderBeanSetupCodeRecursively($typeOrVariable, $recursiveCounter, $canonicalNamesInCallStack)
        ## This should only be called from the #renderBeanSetupCodeForVar() macro.
        ## Renders the code necessary to configure the provided bean and its properties that are beans or lists of beans.
        ## Param: $typeOrVariable            - the Type or Variable for which to render the bean setup code.
        ## Param: $recursiveCounter          - the countdown counter indicating the number of recursive calls remaining.
        ## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
        ##        avoid infinite recursive init loops, in addition to the countdown counter.
        ## Param: $numberOfSettersCalled     - MutableInt containing the total number of setters called in this recurisve call.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderBeanSetupCodeRecursively $typeOrVariable, $recursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled)
        #set($macro.beanClass = $ClassUtils.resolveClass($typeOrVariable))
        #if(!$macro.beanClass)#break #end
        #set($macro.beanClass.testClassLocalFieldName = $typeOrVariable.testClassLocalFieldName)
        #set($macro.preferredSetters = $macro.beanClass.preferredInitSetters.concat($macro.beanClass.methods.filter('jaxbListGetter')))
        #foreach($setter in $macro.preferredSetters)
        #if($foreach.index >= $maxNumberOfSettersToCallPerClass || $numberOfSettersCalled.intValue() >= $maxNumberOfSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #set($macro.newRecursiveCounter = $recursiveCounter - 1)
        #if($setter.jaxbListGetter)
        #set($macro.param = $setter.returnType)
        #else
        #set($macro.param = $setter.parameters.first)
        #end
        #if($macro.param.type.dtoBean && $recursiveCounter > 0)
        #if(!$canonicalNamesInCallStack[$macro.param.type.canonicalName])
        #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($macro.param))
        final $macro.param.type.canonicalText $macro.param.testClassLocalFieldName = $macro.param.initExpression;
        ## Store the beans cannonical name in map to avoid entering a recursive loop.
        #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = true)
        #renderBeanSetupCodeRecursively($macro.param, $macro.newRecursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled)
        #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = false)
        #set($macro.param.shouldStoreInReference = true)
        #else
        #set($macro.param.shouldStoreInReference = false)
        #end
        #elseif(!$macro.param.type.initExpressionBeans.empty && $recursiveCounter > 0)
        ## The setter's param's initExpression contains at least one bean.
        #foreach($beanType in $macro.param.type.initExpressionBeans)
        #if(!$canonicalNamesInCallStack[$beanType.canonicalName])
        #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($beanType))
        final $beanType.canonicalText $beanType.testClassLocalFieldName = $beanType.initExpression;
        #set($canonicalNamesInCallStack[$beanType.canonicalName] = true)
        #renderBeanSetupCodeRecursively($beanType, $macro.newRecursiveCounter, $canonicalNamesInCallStack, $numberOfSettersCalled)
        #set($canonicalNamesInCallStack[$beanType.canonicalName] = false)
        #set($beanType.shouldStoreInReference = true)
        #else
        #set($beanType.shouldStoreInReference = false)
        #end
        #end
        #set($macro.param.type.initExpression = $macro.param.type.createInitExpressionWithLocalFieldBeans($macro.param.type.initExpressionBeans.filter('shouldStoreInReference')))
        #set($macro.param.shouldStoreInReference = false)
        #else
        #set($macro.param.shouldStoreInReference = false)
        #end
        #if($setter.jaxbListGetter)
    ${macro.beanClass.testClassLocalFieldName}.${setter.name}().addAll($macro.param.type.initExpression);
        #else
    ${macro.beanClass.testClassLocalFieldName}.#methodCall($setter, false);
        #end
        #end
        #renderExtraBeanSetupCode($macro.beanClass)
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderExtraBeanSetupCode($beanSourceClass)
        ## Renders any extra statements needed to initialize the instance of the $beanSourceClass.
        ## Param: $beanSourceClass - the SourceClass for the bean to render extra initialization code for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderExtraBeanSetupCode $beanSourceClass)
        #if($StringUtils.equalsAny($beanSourceClass.type.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        final com.amazonaws.services.s3.model.S3Object spyS3Object = spy(new com.amazonaws.services.s3.model.S3Object());
        spyS3Object.setBucketName("bucketName");
        spyS3Object.setKey("key");
        spyS3Object.setObjectContent(new java.io.ByteArrayInputStream("objectContent".getBytes()));
    ${beanSourceClass.testClassLocalFieldName}.setS3Object(spyS3Object);
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderVerifyStatements($method, $diThatThrows, $exceptionToThrow)
        ## Renders verify statements for the given test case.
        ## Param: $method - the method for which the test is being rendered.
        ## Param: $diThatThrows       (optional) - the dependency interaction to stub to throw an exception (or false)
        ## Param: $diExceptionToThrow (optional) - the exception to stub $diThatThrows to throw (or false).
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderVerifyStatements $method, $diThatThrows, $exceptionToThrow)
        #if(!$generateStubsAndVerifyStatements)#break #end
        #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
        #if($diThatThrows)
        #renderPrimaryFlowVerifyStatements($macro.mockedDIs.itemsBefore($diThatThrows))
        #renderPrimaryFlowVerifyStatements($macro.mockedDIs.itemsAfter($diThatThrows).filterOut('field.declaredName', $diThatThrows.field.declaredName))
        #else
        #renderPrimaryFlowVerifyStatements($macro.mockedDIs)
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderPrimaryFlowVerifyStatements($dis)
        ## Renders primary flow verify statements for the given dependency interactions ($dis).
        ## Param: $dis - the dependency interactions to render the primary flow verify statements for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderPrimaryFlowVerifyStatements $dis)
        #foreach($di in $dis)
        #renderPrimaryFlowVerifyStatement($di)
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderPrimaryFlowVerifyStatement($di)
        ## Renders primary flow verify statement for the given dependency interactions ($di).
        ## Param: $di - the dependency interactions to render the primary flow verify statement for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderPrimaryFlowVerifyStatement $di)
        #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
        #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
        #if(!$di.method.returnType)
        verify($macro.qualifier).#methodCall($di.method, false);
        #elseif($di.method.returnType.closeable && $di.method.returnType.shouldStoreInReference)
        verify($di.method.returnType.testClassLocalFieldName).close();
        #end
        #renderExtraVerifyStatements($di)
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderExtraVerifyStatements($di)
        ## Renders any extra verify statements needed for the provided dependency interaction.
        ## Param: $di - the dependency interactions to render the primary flow verify statement for.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderExtraVerifyStatements $di)
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        verify(spyS3Object).close();
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## methodCall($method, $assumeArgsAreStoredInMembers)
        ## Renders an expression to call the given method. This does not include any qualifiers required to reference
        ## the method.
        ## Param: $method - the method or constructor for which to render the call-expression.
        ## Param: $assumeArgsAreStoredInMembers (optional) - assumes the arguments are stored in member fields instead of
        ##        local fields.
        ## Note: This macro uses multiline comments: #* and *# to avoid adding newlines.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(methodCall $method, $assumeArgsAreStoredInMembers)#*
        *#${method.name}#if($method.constructor && $sourceClass.hasGenerics)<>#end#*
        *#(#foreach($param in $method.parameters)#*
        *##if(!$param.shouldStoreInReference)#*
        *#$param.initExpression#*
        *##elseif($assumeArgsAreStoredInMembers)#*
        *#$param.testClassMemberName#*
        *##else#*
        *#$param.testClassLocalFieldName#*
        *##end#*
        *##if($foreach.hasNext),#end#*
        *##end)#*
        *##end

        ##----------------------------------------------------------------------------------------------------------------------
        ## determineTestCaseSuffix($method, $expectedException, $diThatThrows, $diExceptionToThrow)
        ## Determines the suffix to use for the given test case and stores the result in $testCaseSuffix.
        ## Param: $method - the method for which to render the test.
        ## Param: $expectedException  (optional) - the exception this test case is expected to throw (or false)
        ## Param: $diThatThrows       (optional) - the dependency interaction to stub to throw an exception (or false)
        ## Param: $diExceptionToThrow (optional) - the exception to stub $diThatThrows to throw (or false).
        ## Out:   $testCaseSuffix      the suffix to use for this test case.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(determineTestCaseSuffix $method, $expectedException, $diThatThrows, $diExceptionToThrow)
        #if($diExceptionToThrow)
        #set($macro.includeMethodName = false)
        #foreach($di in $method.dependencyInteractions)
        #if($di.field == $diThatThrows.field)
        #foreach($declaredException in $di.method.declaredExceptions)
        #if($declaredException.type.canonicalName == $diExceptionToThrow.type.canonicalName && !($di.method == $diThatThrows.method))
        ## We have two dependency interactions with the same field, same exception, but different methods.
        ## In this case, we need the suffix to be _FieldNameMethodNameThrowsExceptionName instead of
        ## _FieldNameThrowsExceptioName.
        #set($macro.includeMethodName = true)
        #break($foreach.parent)
        #end
        #end
        #end
        #end
        #if($macro.includeMethodName)
        #set($testCaseSuffix = "_${diThatThrows.field.type.name}$StringUtils.capitalize($diThatThrows.method.name)Throws${diExceptionToThrow.type.name}")
        #else
        #set($testCaseSuffix = "_${diThatThrows.field.type.name}Throws${diExceptionToThrow.type.name}")
        #end
        #elseif($expectedException)
        #set($testCaseSuffix = "_Throws${expectedException.type.name}")
        #else
        #set($testCaseSuffix = '')
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderTestMethodForEnum($method, $expectedException)
        ## Renders the enum test method for the given Method. This is similar to #renderTestMethod($method) but calls the
        ## method on each value in the enum and adds an assertEquals call for each result.
        ## Param: $method - the method for which to render the test.
        ## Param: $expectedException (optional) - the declared exception to use in this test method (or false)
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderTestMethodForEnum $method, $expectedException)
        #set($macro.multipleValuesTest = $sourceClass.enumValues.size() > 1 && !$method.static && !$expectedException)
        #set($macro.paramsToStoreInFields = $method.parameters.filter('shouldStoreInReference', true))
        #set($macro.shouldRenderSetup = $macro.paramsToStoreInFields.size() > 0 || ($method.returnType && !$macro.multipleValuesTest && !$expectedException))
        #set($testCaseSuffix = "#if($expectedException)_Throws${expectedException.type.name}#end")
        #set($macro.returnTypeIsArrayWithComparableType = $method.returnType.array && ($method.returnType.deepArrayComponentType.primitive || $method.returnType.deepArrayComponentType.overridesEquals))
        #set($macro.shouldCreateAssertEqualsCall =
        !$macro.multipleValuesTest && $method.returnType && ($method.returnType.primitive || $method.returnType.overridesEquals || $method.returnType.array)
        && ($method.returnType.classT || $method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
        && !$expectedException)
        #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$method.returnType.simple)
        @Test
        public void test${StringUtils.capitalize(${method.name})}${testCaseSuffix}${method.overloadSuffix}() throws Exception {
        #if($macro.shouldRenderSetup)
        // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $macro.paramsToStoreInFields)
        #declareAndInitLocalVar($param, true)
        #end
        #if($macro.shouldStoreExpectedValue)
        #declareAndInitLocalVar($method.returnType, true)
        #end

        #end
        // Run the test
        #set($macro.qualifier = "#if($method.static)${sourceClass.name}#else${sourceClass.name}.${sourceClass.enumFirstValue}#end")
        #if($expectedException)
        assertThatThrownBy(() -> {
    ${macro.qualifier}.#methodCall($method, false);
        }).isInstanceOf(${expectedException.type.canonicalName}.class).hasMessageContaining("message");
        #elseif($macro.multipleValuesTest)
        #foreach($enumValue in $sourceClass.enumValues)
        #if($method.returnType) final $method.returnType.canonicalText ${enumValue.toLowerCase()}Result = #end ${sourceClass.name}.${enumValue}.#methodCall($method, false);
        #end
        #else
        #if($method.returnType) final $method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($method, false);
        #end
        #if(!$expectedException)

        // Verify the results
        #if($macro.multipleValuesTest)
        #foreach($enumValue in $sourceClass.enumValues)
        #assertEqualsCall("$method.returnType.initExpression", "${enumValue.toLowerCase()}Result", $method.returnType);
        #end
        #elseif($macro.shouldCreateAssertEqualsCall)
        #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$method.returnType.testClassLocalFieldName #else $method.returnType.initExpression #end")
        #assertEqualsCall($macro.expectedValueExpression, 'result', $method.returnType);
        #end
        #end
        }
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderSimpleTestMethod($method)
        ## Renders a simple test method for the given $method.
        ## Param: $method - the method for which to render the simple test method.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderSimpleTestMethod $method)
        #if($method.throwsException) @SuppressWarnings("ResultOfMethodCallIgnored") #end
        @Test
        public void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() throws Exception {
        #set($macro.qualifier = "#if($method.static)${sourceClass.name}#else${sourceClass.testClassMemberName}#end")
        ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
        ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
        ## evaluate the block and assign the result in a set statement.
        #define($__workaroundCallExpression) ${macro.qualifier}.#methodCall($method, false) #end
        #set($macro.callExpression = "$__workaroundCallExpression")
        #assertEqualsCall($method.returnType.initExpression, $macro.callExpression, $method.returnType);
        ## Render an assertThatThrownBy(...) call for each exception declared by the method.
        #foreach($declaredException in $method.declaredExceptions)
        assertThatThrownBy(() -> {
    ${macro.qualifier}.#methodCall($method, false);
        }).isInstanceOf(${declaredException.type.canonicalName}.class).hasMessageContaining("message");
        #end
        }
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## Generates an inline mock expression to create a mock for type: $classToMock in a way that is consistent with the
        ## $useStaticImportForInitMocks quick setting.
        ## Param: $classToMock - the name or canonical name of the class to mock.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(mock $classToMock)
        #if($useStaticImportForInitMocks)
        mock($classToMock)
        #else
        Mockito.mock($classToMock)
        #end
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## renderImportsForMatchers()
        ## Renders import statements for the mockito matchers; i.e. any(), eq(), etc.
        ## Matchers will be imported from org.mockito.ArgumentMatchers if it is available on the test classpath or if none of
        ## the mockito classes are on the test classpath. Otherwise, if org.mockito.Matchers is present on the classpath and
        ## org.mockito.ArgumentMatchers is not, Squaretest will import the matchers from org.mockito.Matchers.
        ##----------------------------------------------------------------------------------------------------------------------
        #macro(renderImportsForMatchers)
        #set($macro.matcherCanonicalName = 'org.mockito.ArgumentMatchers')
        #if((!$ClassUtils.isInTestClasspath($macro.matcherCanonicalName))
        && $ClassUtils.isInTestClasspath('org.mockito.Matchers'))
        #set($macro.matcherCanonicalName = 'org.mockito.Matchers')
        #end
        import static ${macro.matcherCanonicalName}.any;
        import static ${macro.matcherCanonicalName}.anyInt;
        import static ${macro.matcherCanonicalName}.anyString;
        import static ${macro.matcherCanonicalName}.eq;
        #end

        ##----------------------------------------------------------------------------------------------------------------------
        ## initializeTemplateDataModel()
        ## Updates mutable fields in $sourceClass and $importLinesRequired based on the Quick Settings at the top of the file
        ## and the architype of the source class. This also sets additional variables used in the rendering logic.
        ## Using a macro to prepare the data model separates the test-class rendering-logic from the configuration and
        ## class architype-detection logic; this keeps the rendering logic simple and easy to modify.
        ##
        ## Global Variables Set by #initializeTemplateDataModel:
        ##
        ##   $dependencies                  a List<Variable> containing all fields the test-class should provide for the
            ##                                  instance of the source class.
            ##   $memberFields                  a subset of $dependencies containing only fields that should be stored in members
            ##                                  in the test class.
            ##   $mockMemberFields              a subset of $memberFields containing only fields that should be mocked.
            ##
            ##   $nonMockMemberFields           a subset of $memberFields containing only fields that should not be mocked.
            ##
            ##   $sourceClassMemberNeeded       a boolean indicating whether or not an instance of the source class should be
            ##                                  created and stored in a member of the test class.
            ##   $shouldUseInjectMocks          a boolean indicating whether or not @InjectMocks should be used to provide
            ##                                  dependencies to the instance of the source class.
            ##   $shouldSetPackageLocalFields   a boolean indicating whether or not the test class should provide dependencies
            ##                                  to the source class by setting package-local fields.
            ##   $mocksNeeded                   true if source class has at least one dependency that should be mocked.
            ##
            ##   $shouldCreateTestsForInstanceMethods
            ##                                  a boolean indicating whether or not test should be created for the instance methods
            ##                                  in the source class.
            ##----------------------------------------------------------------------------------------------------------------------
            #macro(initializeTemplateDataModel)
            ## Determine the archetype of the source class and set the global variables accordingly.
            #set($shouldCreateTestsForInstanceMethods = true)
            #set($mutablePackageLocalInstanceFields = $sourceClass.packageLocalInstanceFields.filter('final', false))
            ## Add the simple names or cannonical names of any custom dependency annotations to the method call below.
            #set($dependencyAnnotatedFields = $sourceClass.fieldsAnnotatedWith('Inject', 'Autowired'))
            #if($sourceClass.enum)
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = false)
            #elseif($sourceClass.singleton)
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = true)
            #elseif($sourceClass.instanceMethods.empty && !$sourceClass.staticMethods.empty)
            ## The source class only has static methods; it's likely a utils class.
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = false)
            #elseif($sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.parameters.empty)
            ## The source class has a parameterized constructor; use it to provide the dependencies.
            #set($dependencies = $sourceClass.preferredConstructor.parameters)
            #set($sourceClassMemberNeeded = true)
            #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.filter('private', true).empty)
            ## The source class has a no-args constructor and private fields annotated with @Inject or @Autowired.
            #set($shouldUseInjectMocks = true)
            #set($dependencies = $dependencyAnnotatedFields)
            #set($sourceClassMemberNeeded = true)
            #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.empty)
            ## The source class has a no-args constructor and visible, dependency-annotated fields;
            ## the test-class should set them.
            #set($dependencies = $dependencyAnnotatedFields)
            #set($shouldSetPackageLocalFields = true)
            #set($sourceClassMemberNeeded = true)
            #elseif($sourceClass.preferredConstructor && !$mutablePackageLocalInstanceFields.empty)
            ## The source class has a no-args constructor and mutable package-local instance fields; assume they are
            ## dependencies and have the test-class set them.
            #set($dependencies = $mutablePackageLocalInstanceFields)
            #set($shouldSetPackageLocalFields = true)
            #set($sourceClassMemberNeeded = true)
            #elseif($sourceClass.preferredConstructor)
            ## The source class has a visible constructor but no package-local fields or dependency-annotated fields.
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = true)
            #elseif(!$sourceClass.packageVisibleStaticCreatorMethods.empty)
            ## The source class has no visible constructor, but does have static creator methods; e.g. parse(...), from(...).
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = false)
            #set($shouldCreateTestsForInstanceMethods = false)
            #else
            #set($dependencies = $FluentList.emptyList())
            #set($sourceClassMemberNeeded = true)
            #end
            ## Update the mutable fields on the dependencies based on the Quick Settings.
            #setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
            ## Filter out fields that should not be stored as members in the test class.
            #set($memberFields = $dependencies.filter('shouldStoreInReference', true))
            #set($mockMemberFields = $memberFields.filter('shouldBeMocked', true))
            #set($nonMockMemberFields = $memberFields.filter('shouldBeMocked', false))
            #set($mocksNeeded = !$mockMemberFields.empty || $shouldUseInjectMocks)
            #initializeMethodParamsWithQuickSettings()
            #initializeMethodReturnTypes()
            #initializeDependencyInteractionMethodParams()
            #askUserToConfirmSettingsIfNeeded()
            #end

            ##----------------------------------------------------------------------------------------------------------------------
            ## initializeMethodReturnTypes()
            ## Sets the returnType.testClassLocalFieldName of each method to 'expectedResult'.
            ##----------------------------------------------------------------------------------------------------------------------
            #macro(initializeMethodReturnTypes)
            #foreach($method in $sourceClass.methods)
            #if($method.returnType)
            #set($method.returnType.testClassLocalFieldName = 'expectedResult')
            #end
            #end
            #end

            ##----------------------------------------------------------------------------------------------------------------------
            ## initializeMethodParamsWithQuickSettings()
            ## Sets mutable fields on the method parameters based on Quick Settings.
            ##----------------------------------------------------------------------------------------------------------------------
            #macro(initializeMethodParamsWithQuickSettings)
            #foreach($method in $sourceClass.methods)
            #foreach($param in $method.parameters)
            ## If useMocksForListenerAndCallbackParameters is set it takes precedence over any initExpressionOverrides.
            #if($useMocksForListenerAndCallbackParameters
            && $param.type.mockable
            && ($StringUtils.endsWithIgnoreCase($param.declaredName, "listener")
            || $StringUtils.endsWithIgnoreCase($param.declaredName, "callback")))
            #useInlineMockForParam($param)
            #set($param.shouldStoreInReference = true)
            #elseif($StringUtils.equalsAny($param.type.canonicalName,
            'javax.servlet.http.HttpServletRequest',
            'javax.servlet.http.HttpServletResponse')
            && $param.type.initExpression == 'null')
            ## Use mocks if the parameter is a servlet request or response and the initExpression is 'null'.
            #useInlineMockForParam($param)
            #set($param.shouldStoreInReference = true)
            #else
            ## Check the initExpressionOverrides.
            #set($macro.initExpressionOverride = false)
            #set($macro.initExpressionOverride = $initExpressionOverrides.get($param.type.canonicalName))
            #if($macro.initExpressionOverride)
            #set($param.initExpression = $macro.initExpressionOverride.initExpression)
            #set($param.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
            #set($param.shouldBeMocked = false)
            #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
            #else
            #set($param.shouldBeMocked = false)
            #end
            #end
            #setTestClassNamesForParam($param)
            #end
            #end
            #end

            ##----------------------------------------------------------------------------------------------------------------------
            ## setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
            ## Sets mutable fields on the $params based on the Quick Settings.
            ## Param: $dependencies the List<Variable> containing the dependencies.
                ## Param: $shouldUseInjectMocks
                ##          a boolean indicating whether or not @InjectMocks should be used to provide dependencies to the instance
                ##          of the source class.
                ## Param: $shouldSetPackageLocalFields
                ##          a boolean indicating whether or not the test class should provide dependencies to the source class by
                ##          setting package-local fields.
                ##----------------------------------------------------------------------------------------------------------------------
                #macro(setDependencyNamesAndInitExpressions $dependencies $shouldUseInjectMocks $shouldSetPackageLocalFields)
                #foreach($dependency in $dependencies)
                ## Use the initExpressionOverride if one is present and we do not need to use @InjectMocks.
                #set($macro.initExpressionOverride = false)
                #set($macro.initExpressionOverride = $initExpressionOverrides.get($dependency.type.canonicalName))
                #if($macro.initExpressionOverride && !$shouldUseInjectMocks)
                #set($dependency.initExpression = $macro.initExpressionOverride.initExpression)
                #set($dependency.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                #set($dependency.shouldBeMocked = false)
                #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
                #elseif($shouldUseInjectMocks && $dependency.type.mockable)
                #set($dependency.shouldBeMocked = true)
                #set($dependency.shouldStoreInReference = true)
                #elseif(!$dependency.shouldBeMocked)
                #set($dependency.shouldStoreInReference = false)
                #end
                ## If the dependencies are provided by setting package-local fields, set them inline instead of storing
                ## references to them in the test class.
                #if($shouldSetPackageLocalFields)
                #if($dependency.shouldBeMocked)
                #useInlineMockForParam($dependency)
                #end
                #set($dependency.shouldStoreInReference = false)
                #end
                #setTestClassNamesForParam($dependency)
                #end
                #end

                ##----------------------------------------------------------------------------------------------------------------------
                ## initializeDependencyInteractionMethodParams()
                ## Updates the data model to use inline initialization expressions for the method arguments in stub (when) and verify
                ## expressions.
                ##----------------------------------------------------------------------------------------------------------------------
                #macro(initializeDependencyInteractionMethodParams)
                #foreach($method in $sourceClass.methods)
                #foreach($di in $method.dependencyInteractions)
                #initializeDependencyInteractionMethodReturnType($di)
                ## Set the parameter init expressions to either values or matcher expressions.
                #set($macro.hasCallableOrRunnableParam = $di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
                #set($macro.hasParamRequiringMatcher = $macro.hasCallableOrRunnableParam || $di.methodCallExpression.arguments.filterOut('actualType.primitive').filterOut('declaredType.classT').containsAnyWith('actualType.overridesEquals', false))
                #foreach($param in $di.method.parameters)
                #set($macro.actualType = $di.methodCallExpression.arguments.get($foreach.index).actualType)
                #set($param.shouldStoreInReference = false)
                ## Handle Callables and Runnables.
                #if($param.type.canonicalName == 'java.util.concurrent.Callable')
                #set($param.initExpression = '(Callable<?>) any(Callable.class)')
                #elseif($param.type.canonicalName == 'java.lang.Runnable')
                #set($param.initExpression = 'any(Runnable.class)')
                ## Handle Class<T> arguments; e.g. Foo.class.
                    #elseif($param.type.classT)
                    #set($macro.classExpression = "${macro.actualType.canonicalNameOrName}.class")
                    #if($macro.hasParamRequiringMatcher)
                    #set($param.initExpression = "eq($macro.classExpression)")
                    #else
                    #set($param.initExpression = "$macro.classExpression")
                    #end
                    ## Handle generic type arguments; e.g. T, not List<T>.
                        #elseif($param.type.generic)
                        #if(!$macro.hasParamRequiringMatcher)
                        ## Use values for all arguments.
                        #set($param.initExpression = $macro.actualType.initExpression)
                        #elseif($macro.actualType.primitive || $macro.actualType.overridesEquals)
                        ## We need to use matchers. Use eq(...) if possible.
                        #set($param.initExpression = "eq($macro.actualType.initExpression)")
                        #else
                        ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                        #set($param.initExpression = "any(${macro.actualType.canonicalNameOrName}.class)")
                        #end
                        ## Handle the case where the formal parameter is an interface or abstract class that does not override
                        ## Object.equals, but the actual type does.
                        #elseif(!$param.type.overridesEquals && $macro.actualType.overridesEquals)
                        #if(!$macro.hasParamRequiringMatcher)
                        ## Use values for all arguments.
                        #set($param.initExpression = $macro.actualType.initExpression)
                        #else
                        ## We need to use matchers. Use eq(...).
                        #set($param.initExpression = "eq($macro.actualType.initExpression)")
                        #end
                        ## Handle all remaining cases where we need to use matchers.
                        #elseif($macro.hasParamRequiringMatcher)
                        #if($param.type.primitive || $param.type.overridesEquals || $macro.actualType.overridesEquals)
                        ## We need to use matchers. Use eq(...) if possible.
                        #set($param.initExpression = "eq($param.initExpression)")
                        #else
                        ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                        #set($param.initExpression = "any(${param.type.canonicalNameOrName}.class)")
                        #end
                        #end
                        #end
                        #end
                        #end
                        #end

                        ##----------------------------------------------------------------------------------------------------------------------
                        ## initializeDependencyInteractionMethodReturnType($di)
                        ## Initializes the initExpression, testClassLocalFieldName and other fields in the $di.method.returnType.
                        ## Param: $di the dependency interaction whose return type will be initialized.
                        ##----------------------------------------------------------------------------------------------------------------------
                        #macro(initializeDependencyInteractionMethodReturnType $di)
                        #if($di.method.returnType.dtoBean || !$di.method.returnType.initExpressionBeans.empty)
                        #set($di.method.returnType.shouldStoreInReference = true)
                        #end
                        #if($StringUtils.equalsAny($di.method.returnType.canonicalName,
                        'com.google.common.util.concurrent.ListenableFuture', 'com.google.common.util.concurrent.SettableFuture'))
                        #set($di.method.returnType.shouldStoreInReference = true)
                        #end
                        #if($di.method.returnType.closeable)
                        #set($di.method.returnType.shouldStoreInReference = true)
                        #if($di.method.returnType.initExpression.equals('null'))
                        #set($di.method.returnType.shouldBeMocked = true)
                        #else
                        #useInlineSpyForParam($di.method.returnType)
                        #set($di.method.returnType.testClassLocalFieldName = "spy$StringUtils.capitalize($di.method.returnType.name)")
                        #end
                        #end
                        #if($di.method.returnType.shouldBeMocked)
                        #set($di.method.returnType.shouldStoreInReference = true)
                        #useInlineMockForParam($di.method.returnType)
                        #set($di.method.returnType.testClassLocalFieldName = "mock$StringUtils.capitalize($di.method.returnType.name)")
                        #end
                        #if($ClassUtils.removePackageQualifiers($di.method.returnType.initExpression).length() > 40)
                        #set($di.method.returnType.shouldStoreInReference = true)
                        #end
                        #end

                        ##----------------------------------------------------------------------------------------------------------------------
                        ## setTestClassNamesForParam($param)
                        ## Sets the Variable.testClassMemberName and Variable.testClassLocalFieldName properties on the given $param
                        ## based on the Quick Settings.
                        ## Param: $param the Variable to update
                        ##----------------------------------------------------------------------------------------------------------------------
                        #macro(setTestClassNamesForParam $param)
                        #if($param.shouldBeMocked)
                        #if(${StringUtils.isNotEmpty($mockDependencyMemberNamePrefix)})
                        #set($param.testClassMemberName = "${mockDependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #elseif (${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
                        #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #end
                        #if(${StringUtils.isNotEmpty($mockParameterLocalFieldNamePrefix)})
                        #set($param.testClassLocalFieldName = "${mockParameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #elseif (${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
                        #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #end
                        #else
                        #if(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
                        #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #end
                        #if(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
                        #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
                        #end
                        #end
                        #end

                        ##----------------------------------------------------------------------------------------------------------------------
                        ## useInlineMockForParam($param)
                        ## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
                        ## Param: $param the Variable to update
                        ##----------------------------------------------------------------------------------------------------------------------
                        #macro(useInlineMockForParam $param)
                        #if($useStaticImportForInitMocks)
                        #set($param.initExpression = "mock(${param.type.canonicalName}.class)")
                        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.mock;"))
                        #else
                        #set($param.initExpression = "Mockito.mock(${param.type.canonicalName}.class)")
                        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
                        #end
                        #set($param.shouldBeMocked = true)
                        #end

                        ##----------------------------------------------------------------------------------------------------------------------
                        ## useInlineSpyForParam($param)
                        ## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
                        ## Param: $param the Variable to update
                        ##----------------------------------------------------------------------------------------------------------------------
                        #macro(useInlineSpyForParam $param)
                        #if($useStaticImportForInitMocks)
                        #set($param.initExpression = "spy($param.initExpression)")
                        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.spy;"))
                        #else
                        #set($param.initExpression = "Mockito.spy($param.initExpression)")
                        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
                        #end
                        #set($param.shouldBeMocked = false)
                        #end

                        ##----------------------------------------------------------------------------------------------------------------------
                        ## askUserToConfirmSettingsIfNeeded()
                        ## Shows a dialog asking the user to confirm which dependencies should be mocked if the template was invoked with
                        ## $shouldAskToConfirmSettings = true. The variable: $shouldAskToConfirmSettings is true when the user invokes the
                        ## "Generate Test - Ask To Confirm Mocks" action from the Squaretest menu.
                        ##----------------------------------------------------------------------------------------------------------------------
                        #macro(askUserToConfirmSettingsIfNeeded)
                        #if($shouldAskToConfirmSettings)
                        ## Show the dialog to ask the user to confirm the provided settings.
                        #set($userProvidedSettings =
                        $UiUtils.askUserToConfirmSettings({
                        'dependencies' : $dependencies,
                        'memberFields' : $memberFields,
                        'mockMemberFields' : $mockMemberFields,
                        'nonMockMemberFields' : $nonMockMemberFields,
                        'sourceClassMemberNeeded' : $sourceClassMemberNeeded,
                        'shouldUseInjectMocks' : $shouldUseInjectMocks,
                        'shouldSetPackageLocalFields' : $shouldSetPackageLocalFields,
                        'mocksNeeded' : $mocksNeeded,
                        'shouldCreateTestsForInstanceMethods' : $shouldCreateTestsForInstanceMethods
                        }))
                        #set($dependencies = $userProvidedSettings.get('dependencies'))
                        #set($memberFields = $userProvidedSettings.get('memberFields'))
                        #set($mockMemberFields = $userProvidedSettings.get('mockMemberFields'))
                        #set($nonMockMemberFields = $userProvidedSettings.get('nonMockMemberFields'))
                        #set($sourceClassMemberNeeded = $userProvidedSettings.get('sourceClassMemberNeeded'))
                        #set($shouldUseInjectMocks = $userProvidedSettings.get('shouldUseInjectMocks'))
                        #set($shouldSetPackageLocalFields = $userProvidedSettings.get('shouldSetPackageLocalFields'))
                        #set($mocksNeeded = $userProvidedSettings.get('mocksNeeded'))
                        #set($shouldCreateTestsForInstanceMethods = $userProvidedSettings.get('shouldCreateTestsForInstanceMethods'))
                        #end
                        #end

                        ## Declare global variables set by initializeTemplateDataModel() to enable partial code-completion in the velocity
                        ## editor bundled with the IntelliJ IDEA Ultimate Edition.
                        #* @vtlvariable name="dependencies" type="java.util.List" *#
                        #* @vtlvariable name="memberFields" type="java.util.List" *#
                        #* @vtlvariable name="mockMemberFields" type="java.util.List" *#
                        #* @vtlvariable name="nonMockMemberFields" type="java.util.List" *#
                        #* @vtlvariable name="sourceClassMemberNeeded" type="boolean" *#
                        #* @vtlvariable name="shouldUseInjectMocks" type="boolean" *#
                        #* @vtlvariable name="shouldSetPackageLocalFields" type="boolean" *#
                        #* @vtlvariable name="mocksNeeded" type="boolean" *#
                        #* @vtlvariable name="shouldCreateTestsForInstanceMethods" type="boolean" *#